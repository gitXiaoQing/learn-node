# NodeJS基础

## 模块

1. 模块初始化
- 一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出被重复利用。

## 代码的组织和部署

1. 版本号
- NPM使用语义版本号来管理代码，语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新：
    - 如果只是修复bug，需要更新Z位
    - 如果是新增了功能，但是向下兼容，需要更新Y位
    - 如果有大变动，向下不兼容，需要更新X位

2. 如果想要下载指定版本的话，可以在包名后边加上@<version>，例如通过以下命令可下载0.0.1版的argv：
``` 
$ npm install argv@0.0.1
```

3. 灵机一点
- npm help <command> 可查看某条命令的详细帮助，如npm help install
- 在package.json所在目录下使用npm install . -g可现在本地安装当前命令行程序，可用于发布前的本地测试
- 使用npm update <package>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本
- 使用npm update <package> -g 可以把全局安装的对应命令行程序更新至最新版
- 使用npm cache clear 可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人
- 使用npm unpublish <package>@<version> 可以撤销发布自己发布过的某个版本代码

## 文件操作
1. Buffer(数据块)
- JS只有字符串数据类型，没有二进制数据类型，因此NodeJS提供了一个与String对等的全局构造函数Buffer来提供对二进制数据的操作。除了可以读取文件得到Buffer的实例外，还能够直接构造，例如：
```
var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);
```
- Buffer与字符串能够互相转化
```
var str = bin.toString('utf-8'); // => "hello"
```
- 将字符串转换为指定编码下的二进制数据：
```
var bin = new Buffer('hello', 'utf-8'); // => <Buffer 68 65 6c 6c 6f>
```
- Buffer与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。至于Buffer，更像是可以做指针操作的C语言数组。

- 如果想要拷贝一份Buffer，得首先创建一个新的Buffer，并通过.copy方法把原Buffer中的数据复制过去。这个类似于申请一块新的内存，并把已有内存中的数据复制过去。

2. Stream(数据流)
- 当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。

3. System(文件系统)
- NodeJS通过fs内置模块提供对文件的操作。fs模块提供的API基本上可以分为以下三类：
    - 文件属性读写:其中常用的有fs.stat、fs.chmod、fs.chown等等。
    - 文件内容读写:其中常用的有fs.readFile、fs.readdir、fs.writeFile、fs.mkdir等等。
    - 底层文件操作:其中常用的有fs.open、fs.read、fs.write、fs.close等等。

4. Path(路径)
- path.normalize    
    将传入的路径转换为标准路径，具体讲的话，除了解析路径中的.与..外，还能去掉多余的斜杠。如果有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的唯一性。   
    **坑出没注意**： 标准化之后的路径里的斜杠在Windows系统下是\，而在Linux系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用.replace(/\\/g, '/')再替换一下标准路径。
- path.join

    将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。

- path.extname

    当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用

## 网络操作
1. HTTP
- 'http'模块提供两种使用方式：
    - 作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。
    - 作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。

- HTTP请求本质上是一个数据流，由请求头（headers）和请求体（body）组成。HTTP请求在发送给服务器时，可以认为是按照从头到尾的顺序一个字节一个字节地以数据流方式发送的。

- HTTP响应本质上也是一个数据流，同样由响应头（headers）和响应体（body）组成。

2. HTTPS
- https模块与http模块极为类似，区别在于https模块需要额外处理SSL证书。

## 异步编程

1. 回调
    - 异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。
    - JS本身是单线程运行的，不可能在一段代码还未结束运行时去运行别的代码，因此也就不存在异步执行的概念。
    - 如果某个函数做的事情是创建一个别的线程或进程，并与JS主线程并行地做一些事情，并在事情做完后通知JS主线程，那情况又不一样了。
    - JS本身是单线程的，无法异步执行，因此我们可以认为setTimeout这类JS规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。除了setTimeout、setInterval这些常见的，这类函数还包括NodeJS提供的诸如fs.readFile之类的异步API
    - 即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。
